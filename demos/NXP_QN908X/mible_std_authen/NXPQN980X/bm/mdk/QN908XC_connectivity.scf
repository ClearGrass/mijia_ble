#! armcc -E
/*
** ###################################################################
**     Processors:          QN908XA
**                          QN908XC
**
**     Compiler:            Keil ARM C/C++ Compiler
**     Reference manual:    QN908X User manual Rev. 1.0 16 February 2016
**     Version:             rev. 1.0, 2016-04-29
**     Build:               b160526
**
**     Abstract:
**         Linker file for the Keil ARM C/C++ Compiler
**
**     Copyright (c) 2016 Freescale Semiconductor, Inc.
**     Copyright 2016 - 2017 NXP
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of copyright holder nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
** ###################################################################
*/

/******************* Map of Kinetis FLASH ***********************************

             0x0008_0000    m_flash_end
    - - - +---------------+ - - - - - - - -
          |   _ _ _ _ _   |
          | Flash config  |
    6k    |   - - - - -   |
          |               |
          |   RESERVED    |  
          |               | m_reserved_flash_start       0x7e000
    - - - +---------------+ - - - - - - - -
          |               | NV_STORAGE_START_ADDRESS
    8k    |  sNVM_region  |
          | - - - - - - - | --- NV_VIRTUAL_PAGE_BOUND
          |  fNVM_region  |
          |               | NV_STORAGE_END_ADDRESS
    - - - +---------------+ - - - - - - - -
          |               | INT_STORAGE_START
          |               |
          |               |
   ~243k  | OTAP Internal |
          |      Storage* |
          |               |
          |               |
          |               | INT_STORAGE_END
    - - - +---------------+ - - - - - - - -      
          |               | m_text_end
          |               |
          |               |
 ~242k**  |  Application  |
          |               |
          |               |
          |               | m_text_start
    - - - +---------------+ - - - - - - - -
	      |               | NVM_TABLE_START
 192 bytes|   NVM TABLE   |
          |               | NVM_TABLE_END
    - - - +---------------+ - - - - - - - -
          |               | m_versionTags_end
 128 bytes|  Version Tags |
          |               | m_versionTags_start
    - - - +---------------+ - - - - - - - -
          |               | m_bootFlags_end
 24 bytes |  Boot Flags*  |
          |               | m_bootFlags_start
    - - - +---------------+ - - - - - - - - 
          |   Interrupt   | m_interrupts_end
  0x114   |    Vectors    |
  bytes   |               | m_interrupts_start
    - - - +---------------+ - - - - - - - -    
          |               | m_bootloader_end
          |               |
   10k    |  Bootloader*  |
          |               |
          |               | m_bootloader_start = m_flash_start
    - - - +---------------+ - - - - - - - -
             0x0000_0000

 * - These sections are optional for certain applications
 ** - Application will occupy all the free space available
*****************************************************************************/




/*** flash memory characteristics ***/
#define m_flash_start   0x00000000
#define m_flash_end     0x0007FFFF
#define m_flash_size    0x00080000
#define m_sector_size   2048       /* 2k  */


#ifndef __ram_vector_table__
  #define __ram_vector_table__ 0
#endif

#ifndef gUseBootloaderLink_d
  #define gUseBootloaderLink_d 0
#endif

#ifndef gNVMSectorCountLink_d
  #define gNVMSectorCountLink_d 4
#endif

#ifndef gUseInternalStorageLink_d
  #define gUseInternalStorageLink_d 0
#endif


/****************************************************
 ******          Flash regions sizes           ******
 ****************************************************/
#define m_bootloader_size         ((gUseBootloaderLink_d) ? (5*m_sector_size) : 0x0)
#define __vector_table_size__     0x114
#define __ram_vector_table_size__ ((__ram_vector_table__) ? 0x114 : 0x0)
#define m_bootFlags_size          ((gUseBootloaderLink_d) ? 0x10 : 0x0)
#define NV_STORAGE_SIZE           (gNVMSectorCountLink_d * m_sector_size)
#define m_reserved_flash_size     (3 * m_sector_size)

#if (gUseInternalStorageLink_d != 0)
  #define used_flash_size         (m_bootloader_size + __vector_table_size__ + m_bootFlags_size + NV_STORAGE_SIZE + m_reserved_flash_size)
  #define INT_STORAGE_SIZE        (m_sector_size * ( (((m_flash_size - used_flash_size) / 2) / m_sector_size) + 1 ))  //Half of the free flash, aligned to m_sector_size
#else
  #define INT_STORAGE_SIZE 0
#endif


/****************************************************
 ******        Flash Regions, low to high      ******
 ****************************************************/
#define m_bootloader_start  m_flash_start
#define m_bootloader_end    (m_bootloader_size > 0) ? (m_bootloader_start + m_bootloader_size - 1) : m_bootloader_start
#define m_interrupts_start  m_bootloader_size
#define m_interrupts_end    (m_interrupts_start + __vector_table_size__ - 1)
#define m_interrupts_size   (m_interrupts_end - m_interrupts_start + 1)
#define m_bootFlags_start   (m_interrupts_end + 1)
#define m_bootFlags_end     (m_bootFlags_start + m_bootFlags_size - 1)
#define m_versionTags_start (m_bootFlags_end + 1)
#define m_versionTags_size  (0x80)
#define m_versionTags_end   (m_versionTags_start + m_versionTags_size - 1)
#define NVM_TABLE_SIZE      (0xc0)
#define NVM_TABLE_START     (NVM_TABLE_END + NVM_TABLE_SIZE - 1)
#define NVM_TABLE_END       (m_versionTags_end + 1)
#define m_text_start        (NVM_TABLE_START + 1)


/****************************************************
 *****        Flash Regions, high to low       ******
 ****************************************************/
          
#define m_reserved_flash_start      (m_flash_size - 3 * m_sector_size)
#define NV_STORAGE_START_ADDRESS    (m_reserved_flash_start - 1)
#define NV_STORAGE_END_ADDRESS      (NV_STORAGE_START_ADDRESS - NV_STORAGE_SIZE + 1)
#define INT_STORAGE_START           (NV_STORAGE_END_ADDRESS - 1)
#define INT_STORAGE_END             (INT_STORAGE_START - INT_STORAGE_SIZE + 1)
#define m_text_end                  (INT_STORAGE_END - 1)
#define m_text_size                 (m_text_end - m_text_start + 1)
#define NV_VIRTUAL_PAGE_BOUND       (NV_STORAGE_START_ADDRESS - (NV_STORAGE_SIZE / 2))


/*********************
 * RAM memory config *
 *********************/
#define rom_bootloader_ram_used 0x400 /* Reserved RAM for ROM Bootloader */
#define m_interrupts_ram_start  (0x04000000 + rom_bootloader_ram_used)
#define m_interrupts_ram_end    (m_interrupts_ram_start + __vector_table_size__ - 1)
#define m_data_start            (m_interrupts_ram_end + 1)
#define m_data_end              0x0401FFFF
#define m_data_size             (m_data_end - m_data_start + 1)


/* RAM memory sizes */
#ifdef __stack_size__
  #define Stack_Size   __stack_size__
#else
  #define Stack_Size   0x0800
#endif

#ifdef __heap_size__
  #define Heap_Size     __heap_size__
#else
  #define Heap_Size     0x0000
#endif



LR_m_text m_interrupts_start m_reserved_flash_start {
  VECTOR_ROM m_interrupts_start m_interrupts_size {
    * (RESET,+FIRST)
  }
  
  BOOT_FLAGS m_bootFlags_start FIXED m_bootFlags_size{
    * (.BootloaderFlags)
  }
  
  VERSION_TAGS m_versionTags_start EMPTY m_versionTags_size{
  }
  
  ER_NVM_TABLE NVM_TABLE_END (NVM_TABLE_SIZE){
    * (NVM_TABLE)
  }
  
  ER_m_text m_text_start FIXED m_text_size {
    * (InRoot$$Sections)
    .ANY (+RO)
  }
  
  INT_STORAGE INT_STORAGE_END EMPTY (INT_STORAGE_START-INT_STORAGE_END+1){
  }
  
  NVM_region NV_STORAGE_END_ADDRESS EMPTY (NV_STORAGE_START_ADDRESS-NV_STORAGE_END_ADDRESS+1){
  }

#if (defined(__ram_vector_table__))
  VECTOR_RAM m_interrupts_ram_start EMPTY __ram_vector_table_size__ {
  }
#else
  VECTOR_RAM m_interrupts_start EMPTY 0 {
  }
#endif

  RW_m_data m_data_start m_data_size-Stack_Size-Heap_Size {
    .ANY (+RW +ZI)
    *(.textrw)
  }
  ARM_LIB_HEAP +0 ALIGN 8 EMPTY Heap_Size {
  }
  ARM_LIB_STACK +0 ALIGN 8 EMPTY Stack_Size {
  }

}
